
#include <fstream>

#define _USE_MATH_DEFINES
#include <cmath>

#include <boost/timer/timer.hpp>


#include "LogDefines.hpp"
#include "AssertionDebug.hpp"

#include "DynamicsState.hpp"
#include "SharedBufferDynSys.hpp"
#include "StateRecorder.hpp"
#include "MoreauTimeStepper.hpp"
#include "InclusionSolverNT.hpp"
#include "InclusionSolverCO.hpp"
#include "InclusionSolverCONoG.hpp"

#include "DynamicsSystem.hpp"

#include "CommonFunctions.hpp"
#include "QuaternionHelpers.hpp"

#include "FileManager.hpp"


using namespace std;



template<typename TConfig>
SimulationManager<TConfig>::SimulationManager()
{

    m_pSimulationLog = NULL;

    if(Logging::LogManager::getSingletonPtr()->existsLog("SimulationLog")) {
        m_pSimulationLog = Logging::LogManager::getSingletonPtr()->getLog("SimulationLog");
    } else {
        boost::filesystem::path filePath = FileManager::getSingletonPtr()->getGlobalDirectoryPath();
        filePath /= GLOBAL_LOG_FOLDER_DIRECTORY;
        filePath /= "SimulationLog.log";
        m_pSimulationLog = Logging::LogManager::getSingletonPtr()->createLog("SimulationLog",true,true,filePath);
        m_pSimulationLog->logMessage("Creating SimulationManager...");
    }


}
template<typename TConfig>
SimulationManager<TConfig>::~SimulationManager()
{
  DECONSTRUCTOR_MESSAGE

}

template<typename TConfig>
void SimulationManager<TConfig>::setup(){
    setup("SceneFile.xml");
}

template<typename TConfig>
void SimulationManager<TConfig>::setup(boost::filesystem::path sceneFilePath)
{


  m_pSimulationLog->logMessage("---> SimulationManager::setup(): ");


  m_pDynSys = boost::shared_ptr< DynamicsSystemType >( new DynamicsSystemType());

  // Parse the Scene from XML! ==========================
  m_pSceneParser = boost::shared_ptr< SceneParser<TConfig> >( new SceneParser<TConfig>( m_pDynSys) );
  m_pSceneParser->parseScene(sceneFilePath);

  m_nSimBodies = m_pSceneParser->getNumberOfSimBodies();
  // =====================================================


  m_pSharedBuffer = boost::shared_ptr<SharedBufferDynSys<LayoutConfigType> >(new SharedBufferDynSys<LayoutConfigType>(m_nSimBodies));
  m_pTimestepper = boost::shared_ptr< TimeStepperType >( new TimeStepperType(m_nSimBodies, m_pDynSys, m_pSharedBuffer) );


  m_pStateRecorder = boost::shared_ptr<StateRecorder<LayoutConfigType> >(new StateRecorder<LayoutConfigType>(m_nSimBodies));

  m_pSharedBuffer->initializeStatePool(m_pSceneParser->getInitialConditionSimBodies());

  m_pSimulationLog->logMessage("---> added all objects(): ");
}


template<typename TConfig>
void SimulationManager<TConfig>::threadRunRecord()
{

  static double timelineSimulation;

  m_pSimulationLog->logMessage(" SimulationManager: Simulation entering...");


  initRecordThread();

  //Reset Timestepper!
   m_pTimestepper->reset();

  //Open File
  bool fileOK = false;
  if(m_pTimestepper->m_Settings.m_eSimulateFromReference == TimeStepperSettings<LayoutConfigType>::CONTINUE){
      fileOK = m_pStateRecorder->createSimFileCopyFromReference(m_SimFilePath,m_pTimestepper->m_Settings.m_simStateReferenceFile);
  }else{
      fileOK = m_pStateRecorder->createSimFile(m_SimFilePath);
  }

  if(fileOK)
  {

    // Write first initial value out!
    if(m_pTimestepper->m_Settings.m_eSimulateFromReference == TimeStepperSettings<LayoutConfigType>::NONE){
      m_pStateRecorder->write(m_pTimestepper->getFrontStateBuffer().get());
    }
    // wait for vis thread! (which does some loops before)
    boost::timer::cpu_timer global_time;
    global_time.start();

    while(1)
    {

      // Do one iteration
      m_pTimestepper->doOneIteration();

      // get global time for logging!
      timelineSimulation = ((double)global_time.elapsed().wall)*1e-9;
      // Write Data to SystemDataFile (maps all data to back buffer!)
      m_pTimestepper->writeIterationToSystemDataFile(timelineSimulation);
      // Write Data to CollisionDataFile
      m_pTimestepper->writeIterationToCollisionDataFile();
      // Write  State to Sim File
      m_pStateRecorder->write(m_pTimestepper->getFrontStateBuffer().get());

      // Check if simulation can be aborted!
      if(m_pTimestepper->finished()){
         m_pSimulationLog->logMessage(" SimulationManager: Timestepper finished, exit...");
         break;
      }
    }

    cleanUpRecordThread();
  }

  m_pSimulationLog->logMessage(" SimulationManager: Simulation leaving...");
  return;
}
template<typename TConfig>
void SimulationManager<TConfig>::initRecordThread()
{
  // Get new folder path
  m_SimFolderPath = FileManager::getSingletonPtr()->getNewSimFolderPath(SIMULATION_FOLDER_PATH,SIM_FOLDER_PREFIX_RECORD);

   // Sim file path
     m_SimFilePath = m_SimFolderPath;
     std::string filename = SIM_FILE_PREFIX;
     filename += SIM_FILE_EXTENSION;
     m_SimFilePath /= filename;

   boost::filesystem::path m_SceneFilePath = m_SimFolderPath;
   filename = SIM_SCENE_FILE_NAME;
   filename += ".xml";
   m_SceneFilePath /= filename;

   FileManager::getSingletonPtr()->copyFile(m_pSceneParser->getCurrentSceneFileDirectory(),m_SceneFilePath,true);

  m_pTimestepper->initLogs(m_SimFolderPath);

}
template<typename TConfig>
void SimulationManager<TConfig>::cleanUpRecordThread(){
   m_pTimestepper->closeAllFiles();
   m_pStateRecorder->closeSimFile();
}

template<typename TConfig>
void SimulationManager<TConfig>::startSim()
{
  threadRunRecord();
}


