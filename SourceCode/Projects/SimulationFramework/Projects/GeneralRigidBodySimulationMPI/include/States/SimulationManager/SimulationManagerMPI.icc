#include <fstream>

#define _USE_MATH_DEFINES
#include <cmath>

#include "LogDefines.hpp"
#include "AssertionDebug.hpp"

#include <RenderContext.hpp>

#include "DynamicsState.hpp"
#include "SharedBufferDynSys.hpp"
#include "StateRecorder.hpp"
#include "MoreauTimeStepper.hpp"
#include "InclusionSolverNT.hpp"
#include "InclusionSolverCO.hpp"
#include "InclusionSolverCONoG.hpp"

#include "DynamicsSystem.hpp"

#include "CommonFunctions.hpp"
#include "QuaternionHelpers.hpp"

#include "FileManager.hpp"


using namespace std;



template<typename TConfig>
SimulationManagerMPI<TConfig>::SimulationManagerMPI() {

}
template<typename TConfig>
SimulationManagerMPI<TConfig>::~SimulationManagerMPI() {
    DECONSTRUCTOR_MESSAGE

}

template<typename TConfig>
void SimulationManagerMPI<TConfig>::setup() {
    setup("SceneFile.xml");
}

template<typename TConfig>
void SimulationManagerMPI<TConfig>::setup(boost::filesystem::path sceneFilePath) {

    //Each Process copies its SceneFile.xml to the folders, that each Process can read its own file (better)
    boost::filesystem::path sceneFilePathNew = FileManager::getSingletonPtr()->copyFile(sceneFilePath,
            FileManager::getSingletonPtr()->getGlobalDirectoryPath());

    //Make log!
    m_pSimulationLog = NULL;
    if(Logging::LogManager::getSingletonPtr()->existsLog("SimulationLog")) {
        m_pSimulationLog = Logging::LogManager::getSingletonPtr()->getLog("SimulationLog");
    } else {
        boost::filesystem::path filePath = FileManager::getSingletonPtr()->getGlobalDirectoryPath();
        filePath /= GLOBAL_LOG_FOLDER_DIRECTORY;
        filePath /= "SimulationLog.log";
        m_pSimulationLog = Logging::LogManager::getSingletonPtr()->createLog("SimulationLog",true,true,filePath);
        m_pSimulationLog->logMessage("Creating SimulationManager...");
    }


    m_pDynSys = boost::shared_ptr< DynamicsSystemType >( new DynamicsSystemType());

    // Parse the Scene from XML! ==========================
    m_pSceneParser = boost::shared_ptr< SceneParser<TConfig> >( new SceneParser<TConfig>( m_pDynSys) );

    m_pSceneParser->parseScene(sceneFilePathNew);

    m_nSimBodies = m_pSceneParser->getNumberOfSimBodies();
    // =====================================================


    m_pSharedBuffer = boost::shared_ptr<SharedBufferDynSys<LayoutConfigType> >(new SharedBufferDynSys<LayoutConfigType>(m_nSimBodies));
    m_pTimestepper = boost::shared_ptr< TimeStepperType >( new TimeStepperType(m_nSimBodies, m_pDynSys, m_pSharedBuffer) );


    m_pStateRecorder = boost::shared_ptr<StateRecorder<LayoutConfigType> >(new StateRecorder<LayoutConfigType>(m_nSimBodies));

    m_pSharedBuffer->initializeStatePool(m_pSceneParser->getInitialConditionSimBodies());

    m_pSimulationLog->logMessage("---> added all objects(): ");
}


//template<typename TConfig>
//void SimulationManagerMPI<TConfig>::threadRunRecord() {
//
//    static double timelineSimulation;
//
//    m_pSimulationLog->logMessage(" SimulationManagerMPI: RecordThread entering...");
//    setSimThreadRunning(true);
//
//
//    initRecordThread();
//
//    //Reset Timestepper!
//    m_pTimestepper->reset();
//
//    //Open File
//    bool fileOK = false;
//    if(m_pTimestepper->m_Settings.m_eSimulateFromReference == TimeStepperSettings<LayoutConfigType>::CONTINUE) {
//        fileOK = m_pStateRecorder->createSimFileCopyFromReference(m_SimFilePath,m_pTimestepper->m_Settings.m_simStateReferenceFile);
//    } else {
//        fileOK = m_pStateRecorder->createSimFile(m_SimFilePath);
//    }
//
//    if(fileOK) {
//
//        // Write first initial value out!
//        if(m_pTimestepper->m_Settings.m_eSimulateFromReference == TimeStepperSettings<LayoutConfigType>::NONE) {
//            m_pStateRecorder->write(m_pTimestepper->getFrontStateBuffer().get());
//        }
//        // wait for vis thread! (which does some loops before)
//
//        resetTimelineSimulation();
//
//        while(!isSimThreadToBeStopped()) {
//
//
//            // Read all inputs
//            readSharedBuffer();
//            // Do one iteration
//            m_pTimestepper->doOneIteration();
//            // Write outputs
//            writeSharedBuffer();
//
//            // get global time for logging!
//            timelineSimulation = getTimelineSimulation();
//            // Write Data to SystemDataFile (maps all data to back buffer!)
//            m_pTimestepper->writeIterationToSystemDataFile(timelineSimulation);
//            // Write Data to CollisionDataFile
//            m_pTimestepper->writeIterationToCollisionDataFile();
//            // Write  State to Sim File
//            m_pStateRecorder->write(m_pTimestepper->getFrontStateBuffer().get());
//
//            // Check if simulation can be aborted!
//            if(m_pTimestepper->finished()) {
//                m_pSimulationLog->logMessage(" SimulationManagerMPI: Timestepper finished, exit...");
//                break;
//            }
//        }
//
//        cleanUpRecordThread();
//    }
//
//    setSimThreadRunning(false);
//    m_pSimulationLog->logMessage(" SimulationManagerMPI: RecordThread leaving...");
//    return;
//}
//template<typename TConfig>
//void SimulationManagerMPI<TConfig>::initRecordThread() {
//    // Get new folder path
//    m_SimFolderPath = FileManager::getSingletonPtr()->getNewSimFolderPath(SIMULATION_FOLDER_PATH,SIM_FOLDER_PREFIX_RECORD);
//
//    // Sim file path
//    m_SimFilePath = m_SimFolderPath;
//    std::string filename = SIM_FILE_PREFIX;
//    filename += SIM_FILE_EXTENSION;
//    m_SimFilePath /= filename;
//
//    boost::filesystem::path m_SceneFilePath = m_SimFolderPath;
//    filename = SIM_SCENE_FILE_NAME;
//    filename += ".xml";
//    m_SceneFilePath /= filename;
//
//    FileManager::getSingletonPtr()->copyFile(m_pSceneParser->getCurrentSceneFileDirectory(),m_SceneFilePath,true);
//
//    m_pTimestepper->initLogs(m_SimFolderPath);
//
//}
//template<typename TConfig>
//void SimulationManagerMPI<TConfig>::cleanUpRecordThread() {
//    m_pTimestepper->closeAllFiles();
//    m_pStateRecorder->closeSimFile();
//}

//
//template<typename TConfig>
//void SimulationManagerMPI<TConfig>::readSharedBuffer() {
//
//}
//
//template<typename TConfig>
//void SimulationManagerMPI<TConfig>::writeSharedBuffer() {
//    static int iterations = 0;
//    iterations++;
//
//    //if(iterations%100==0){
//    setIterationTime(m_pTimestepper->m_AvgTimeForOneIteration, m_pTimestepper->m_MaxTimeForOneIteration);
//    setNumberOfContacts(m_pTimestepper->m_pInclusionSolver->m_nContacts);
//
//    //}
//
//}
//
//template<typename TConfig>
//void SimulationManagerMPI<TConfig>::startSimThread() {
//
//    // TODO Switch Update function to the SimThread update!
//
//    if (!isSimThreadRunning()) {
//
//        setThreadToBeStopped(false);
//
//        //Start Dynamics Thread===========================================
//        m_pThread = new boost::thread( boost::bind(&SimulationManagerMPI<TConfig>::threadRunRecord, &*this) );
//        m_eSimThreadRunning = SimulationManagerMPIBase::RECORD;
//        m_pSimulationLog->logMessage(" SimulationManagerMPI:: Start Thread: SimThread in RECORD mode started ...");
//
//    } else {
//        m_pSimulationLog->logMessage("SimulationManagerMPI:: A SimThread is already running!");
//    }
//}
//
//
//template<typename TConfig>
//void SimulationManagerMPI<TConfig>::waitForSimThread() {
//    m_pThread->join();
//    m_eSimThreadRunning = SimulationManagerMPIBase::NONE;
//}
//
//template<typename TConfig>
//void SimulationManagerMPI<TConfig>::stopSimThread() {
//
//    if (isSimThreadRunning()) {
//        setThreadToBeStopped(true);
//        m_pThread->join();
//        m_pSimulationLog->logMessage("SimulationManagerMPI:: Stop Thread: SimThread has been stopped!");
//
//        m_eSimThreadRunning = SimulationManagerMPIBase::NONE;
//    } else {
//        m_pSimulationLog->logMessage("SimulationManagerMPI:: Stop Thread: SimThread is not running!");
//    }
//}
