#include <fstream>

#define _USE_MATH_DEFINES
#include <cmath>

#include "TypeDefs.hpp"
#include "LogDefines.hpp"
#include "AssertionDebug.hpp"
#include "AssertionDebugMPI.hpp"

#include "DynamicsState.hpp"
#include "SharedBufferDynSys.hpp"
#include "StateRecorder.hpp"

#include "MoreauTimeStepperMPI.hpp"
#include "InclusionSolverCONoGMPI.hpp"

#include "DynamicsSystemMPI.hpp"

#include "CommonFunctions.hpp"
#include "QuaternionHelpers.hpp"

#include "FileManager.hpp"

#include "MPIMessages.hpp"
#include "MPICommunicationFunctions.hpp"


using namespace std;



template<typename TConfig>
SimulationManagerMPI<TConfig>::SimulationManagerMPI() {

}
template<typename TConfig>
SimulationManagerMPI<TConfig>::~SimulationManagerMPI() {
    DECONSTRUCTOR_MESSAGE

}

template<typename TConfig>
void SimulationManagerMPI<TConfig>::setup() {
    setup("SceneFile.xml");
}

template<typename TConfig>
void SimulationManagerMPI<TConfig>::setup(boost::filesystem::path sceneFilePath) {

    //Each Process copies its SceneFile.xml to the folders, that each Process can read its own file (better)
    boost::filesystem::path sceneFilePathNew = FileManager::getSingletonPtr()->copyFile(sceneFilePath,
            FileManager::getSingletonPtr()->getLocalDirectoryPath());

    //Make log!
    m_pSimulationLog = NULL;
    if(Logging::LogManager::getSingletonPtr()->existsLog("SimulationLog")) {
        m_pSimulationLog = Logging::LogManager::getSingletonPtr()->getLog("SimulationLog");
    } else {
        boost::filesystem::path filePath = FileManager::getSingletonPtr()->getLocalDirectoryPath();
        filePath /= GLOBAL_LOG_FOLDER_DIRECTORY;
        filePath /= "SimulationLog.log";
        m_pSimulationLog = Logging::LogManager::getSingletonPtr()->createLog("SimulationLog",true,true,filePath);
        m_pSimulationLog->logMessage("Creating SimulationManager...");
    }

    m_pSimulationLog->logMessage("---> SimulationManager::setup(): ");

    m_pDynSys = boost::shared_ptr< DynamicsSystemType >( new DynamicsSystemType());

    // Parse the Scene from XML! ==========================
    m_pSceneParser = boost::shared_ptr< SceneParserMPI<TConfig> >( new SceneParserMPI<TConfig>( m_pDynSys, m_MPIProcInfo) );

    m_pSceneParser->parseScene(sceneFilePathNew);

    m_nSimBodies = m_pSceneParser->getNumberOfSimBodies();

    m_nGlobalSimBodies = m_pSceneParser->getNumberOfGlobalSimBodies();

    LOG(m_pSimulationLog,  "---> Scene parsing finshed: Added "<< m_nSimBodies << " Bodies!" << std::endl;);

    // Do Safty Check
    // Do a Reduction of all Simbodies, to count if no bodies are missing!
    checkNumberOfBodiesInProcess();

    // =====================================================


    m_pTimestepper = boost::shared_ptr< TimeStepperType >( new TimeStepperType(m_nSimBodies, m_pDynSys) );

    m_pStateRecorder = boost::shared_ptr<StateRecorderBody<DynamicsSystemType> >(new StateRecorderBody<DynamicsSystemType>());

    m_pSimulationLog->logMessage("---> setup finished! ");
}


template<typename TConfig>
bool SimulationManagerMPI<TConfig>::checkNumberOfBodiesInProcess(){

   int numberOfBodiesInSimulation = 0;
   int nSimBodies = m_nSimBodies;

   boost::timer::cpu_timer timer;

   timer.start();
      MPI_Reduce(&nSimBodies,&numberOfBodiesInSimulation, 1, MPI_INT, MPI_SUM, ProcessInfoType::MASTER, MPI_COMM_WORLD);
   timer.stop();
   double elapsed = ((double)timer.elapsed().wall)*1e-9;

   if(m_MPIProcInfo.hasMasterRank()){
        LOG(m_pSimulationLog,  " Allreduce needed: " << elapsed <<"sec."<<std::endl; );

       if(numberOfBodiesInSimulation != m_nGlobalSimBodies){
            LOG(m_pSimulationLog,  "ERROR: ---> Body check NOT successful! : "<< numberOfBodiesInSimulation <<"!="<< m_nGlobalSimBodies<< std::endl;);
            ERRORMSGMPI("Body check Not successfull");
       }

        LOG(m_pSimulationLog,  "---> Body check successfull!: "<<numberOfBodiesInSimulation<<" SimBodies in Simulation" << std::endl;);
    }else{
        LOG(m_pSimulationLog,  "---> Body check ... (sent # of bodies) !"<< std::endl;);
    }

}

template<typename TConfig>
void SimulationManagerMPI<TConfig>::startSim()
{

  static double timelineSimulation;

  m_pSimulationLog->logMessage(" SimulationManager: Simulation entering...");

  initSim();


//  if(fileOK)
//  {
//
//    // Write first initial value out!
//    if(m_pTimestepper->m_Settings.m_eSimulateFromReference == TimeStepperSettings<LayoutConfigType>::NONE){
//      m_pStateRecorder->write(m_pTimestepper->getFrontStateBuffer().get());
//    }
//    // wait for vis thread! (which does some loops before)
//    boost::timer::cpu_timer global_time;
//    global_time.start();
//
//    while(1)
//    {
//
//      // Do one iteration
//      m_pTimestepper->doOneIteration();
//
//      // get global time for logging!
//      timelineSimulation = ((double)global_time.elapsed().wall)*1e-9;
//      // Write Data to SystemDataFile (maps all data to back buffer!)
//      m_pTimestepper->writeIterationToSystemDataFile(timelineSimulation);
//      // Write Data to CollisionDataFile
//      m_pTimestepper->writeIterationToCollisionDataFile();
//      // Write  State to Sim File
//      m_pStateRecorder->write(m_pTimestepper->getFrontStateBuffer().get());
//
//      // Check if simulation can be aborted!
//      if(m_pTimestepper->finished()){
//         m_pSimulationLog->logMessage(" SimulationManager: Timestepper finished, exit...");
//         break;
//      }
//    }
//
//    cleanUpRecordThread();
//  }
//
//  m_pSimulationLog->logMessage(" SimulationManager: Simulation leaving...");
//  return;
}

template<typename TConfig>
void SimulationManagerMPI<TConfig>::initSim()
{


    MPILayer::GenericMessage1<boost::filesystem::path> message;

    if(m_MPIProcInfo.hasMasterRank()){ // Only master process
       // Get new sim folder path relative to global directory

       m_SimFolderPath = FileManager::getSingletonPtr()->getNewSimFolderPath(SIMULATION_FOLDER_PATH,SIM_FOLDER_PREFIX_RECORD);

       boost::filesystem::path sceneFilePath = m_SimFolderPath;
       std::string filename = SIM_SCENE_FILE_NAME;
       filename += ".xml";
       sceneFilePath /= filename;

        FileManager::getSingletonPtr()->copyFile(m_pSceneParser->getParsedSceneFile(),sceneFilePath,true);

        // Need to broadcast the filename of the actual folder
        // Broadcast: m_SimFolderPath

        message.m_data.get<0>() = m_SimFolderPath;

        MPILayer::MPISendBroadcast(message, m_MPIProcInfo.getRank(), MPI_COMM_WORLD);
    }else{ // All other processes
        MPILayer::MPIReceiveBroadcast(message, m_MPIProcInfo.getMasterRank(), MPI_COMM_WORLD);

        m_SimFolderPath = message.m_data.get<0>();
    }

    // Create same folder name in Local Process Directory, to save all data...
    boost::filesystem::path localSimFolderPath = FileManager::getSingletonPtr()->getLocalDirectoryPath();
    localSimFolderPath /= m_SimFolderPath.filename();
    if(!boost::filesystem::create_directories(localSimFolderPath)){
       LOG(m_pSimulationLog,  "ERROR: ---> Could not create directory: " << localSimFolderPath.string() << std::endl;);
       ERRORMSGMPI("ERROR: ---> Could not create directory: " << localSimFolderPath.string() << std::endl )
    }


    m_pStateRecorder->addFiles(m_SimFolderPath, m_pDynSys->m_SimBodies);

    m_pTimestepper->initLogs(localSimFolderPath);

}
