#include <fstream>

#define _USE_MATH_DEFINES
#include <cmath>

#include <boost/shared_ptr.hpp>

#include "TypeDefs.hpp"
#include "LogDefines.hpp"
#include "AssertionDebug.hpp"

#include "DynamicsState.hpp"
#include "SharedBufferDynSys.hpp"
#include "StateRecorder.hpp"
#include "StateRecorderBody.hpp"
#include "StateRecorderProcess.hpp"
#include "StateRecorderMPI.hpp"

#include TimeStepper_INCLUDE_FILE
#include DynamicsSystem_INCLUDE_FILE

#include "CommonFunctions.hpp"
#include "QuaternionHelpers.hpp"

#include "FileManager.hpp"

#include "MPIMessages.hpp"
#include "MPICommunication.hpp"




SimulationManagerMPI::SimulationManagerMPI() {

}

SimulationManagerMPI::~SimulationManagerMPI() {
    DECONSTRUCTOR_MESSAGE

}


void SimulationManagerMPI::setup() {
    setup("SceneFile.xml");
}


void SimulationManagerMPI::setup(boost::filesystem::path sceneFilePath) {

    //Each Process copies its SceneFile.xml to the folders, that each Process can read its own file (better)
    boost::filesystem::path sceneFilePathNew = FileManager::getSingletonPtr()->copyFile(sceneFilePath,
            FileManager::getSingletonPtr()->getLocalDirectoryPath());

    //Make log!
    m_pSimulationLog = nullptr;
    if(Logging::LogManager::getSingletonPtr()->existsLog("SimulationLog")) {
        m_pSimulationLog = Logging::LogManager::getSingletonPtr()->getLog("SimulationLog");
    } else {
        boost::filesystem::path filePath = FileManager::getSingletonPtr()->getLocalDirectoryPath();
        filePath /= GLOBAL_LOG_FOLDER_DIRECTORY;
        filePath /= "SimulationLog.log";
        m_pSimulationLog = Logging::LogManager::getSingletonPtr()->createLog("SimulationLog",SIMULATION_LOG_TO_CONSOLE,true,filePath);
    }

    m_pSimulationLog->logMessage("---> SimulationManagerMPI::setup(): ");

    // MPI Process Commnunicator

    m_pProcCommunicator = boost::shared_ptr<ProcessCommunicatorType >(new ProcessCommunicatorType(
                                                    MPILayer::MPIGlobalCommunicators::getSingletonPtr()->getCommunicator(
                                                      MPILayer::MPICommunicatorId::SIM_COMM
                                                    )
                                           ));
    m_pSimulationLog->logMessage("--->SimulationManagerMPI:: Added ProcessCommunicator");


    m_pDynSys = boost::shared_ptr< DynamicsSystemType >( new DynamicsSystemType());
    m_pSimulationLog->logMessage("--->SimulationManagerMPI:: Added DynamicsSystem");

    // Parse the Scene from XML! ==========================

    m_pSceneParser = boost::shared_ptr< SceneParserMPI >( new SceneParserMPI( m_pDynSys, m_pProcCommunicator ) );
    m_pSimulationLog->logMessage("---> SimulationManagerMPI:: Added SceneParser and parse Scene");
    m_pSceneParser->parseScene(sceneFilePathNew);
    m_nGlobalSimBodies = m_pSceneParser->getNumberOfGlobalSimBodies();
    m_nSimBodies = m_pSceneParser->getNumberOfSimBodies();
    LOG(m_pSimulationLog,  "---> SimulationManagerMPI:: SceneParsing finshed: Added "<< m_nSimBodies << " Bodies!" << std::endl;);
    LOG(m_pSimulationLog,  "---> SimulationManagerMPI:: Global Bodies in Simulation "<< m_nGlobalSimBodies<< " Bodies!" << std::endl;);

    // Do Safty Check
    // Do a Reduction of all Simbodies, to count if no bodies are missing!
    m_pSimulationLog->logMessage("---> Check number of Bodies in Process:");
    checkNumberOfBodiesInProcess();

    // =====================================================

    //Uncomment if StateRecorderType = StateRecorderBodys
    //m_pStateRecorder  =  boost::shared_ptr<StateRecorderType >(new StateRecorderType(true,m_pProcCommunicator->getProcInfo()->getRank()));

    m_pStateRecorder  =  boost::shared_ptr<StateRecorderType >(new StateRecorderType(m_nGlobalSimBodies,
                                                                boost::static_pointer_cast<ProcessCommunicatorType::ProcessInfoType>(m_pProcCommunicator)));
    // =====================================================


    //Uncomment if StateRecorderType = StateRecorderBodys
    //Set up delegate function from BodyCommunicator to StateRecorederBody (close and open files)
    //        m_pBodyCommunicator->addDelegateLocalRemove(
    //            BodyCommunicator<DynamicsSystemType>::AddDelegate::template
    //            from_method< StateRecorderType,&StateRecorderType::removeBody>
    //            (& *m_pStateRecorder.get())
    //        );
    //        m_pBodyCommunicator->addDelegateLocalAdd(
    //            BodyCommunicator<DynamicsSystemType>::AddDelegate::template
    //            from_method< StateRecorderType,&StateRecorderType::addBody>
    //            (& *m_pStateRecorder.get())
    //        );
    // TODO: Danger shared_ptr.get() in delegate class,
    //as along as there is the SimMgrMpi there is a NbCommunicator and a StatRecorder, so no problem
    // ===============================================

    m_pTimestepper = boost::shared_ptr< TimeStepperType >( new TimeStepperType(m_pDynSys, m_pProcCommunicator) );

    m_pSimulationLog->logMessage("---> Initialize ProcessCommunicator buffers...");
    m_pProcCommunicator->initializeNeighbourBuffers();

    m_pSimulationLog->logMessage("---> SimulationManagerMPI::setup() finished!");
}



void SimulationManagerMPI::checkNumberOfBodiesInProcess() {

    int numberOfBodiesInSimulation = 0;
    int nSimBodies = m_nSimBodies;

    CPUTimer timer;

    timer.start();
    LOG(m_pSimulationLog,  "MPI> Body check,  MPI_Reduce... "<< std::endl;)
    MPI_Reduce(&nSimBodies,&numberOfBodiesInSimulation, 1, MPI_INT, MPI_SUM, m_pProcCommunicator->getMasterRank(), m_pProcCommunicator->getCommunicator());
    double elapsed = ((double)timer.elapsed())*1e-9;

    if(m_pProcCommunicator->hasMasterRank()) {
        LOG(m_pSimulationLog,  "MPI> Allreduce needed: " << elapsed <<"sec."<<std::endl; );

        if(numberOfBodiesInSimulation != m_nGlobalSimBodies) {
            LOG(m_pSimulationLog,  "ERROR:---> Body check NOT successful! : "<< numberOfBodiesInSimulation <<"!="<< m_nGlobalSimBodies<< std::endl;);
            ERRORMSG("Body check Not successfull");
        }

        LOG(m_pSimulationLog,  "---> Body check successfull!: "<<numberOfBodiesInSimulation<<" SimBodies in Simulation" << std::endl;);
    } else {
        LOG(m_pSimulationLog,  "---> Body check ... (sent # of bodies) !"<< std::endl;);
    }

}


void SimulationManagerMPI::getMaxRuntime(PREC runtime){

    LOG(m_pSimulationLog,  "MPI> Get Max Runtime,  MPI_Reduce... "<< std::endl;);
    PREC maxRuntime;

    MPI_Reduce(&runtime,&maxRuntime, 1, MPI_DOUBLE, MPI_MAX, m_pProcCommunicator->getMasterRank(), m_pProcCommunicator->getCommunicator());

    if(m_pProcCommunicator->hasMasterRank()){
        LOG(m_pSimulationLog, "---> Total runtime for simulation needed: "<<maxRuntime<< " sec. " << std::endl;);
    }else{
        LOG(m_pSimulationLog, "---> Runtime sent ... !"<< std::endl;);
    }


}



void SimulationManagerMPI::startSim() {



    static double timelineSimulation;

    m_pSimulationLog->logMessage("---> SimulationManager: Simulation entering...");

    initSim();



    //Write first initial value out!
//    for(auto it = m_pDynSys->m_SimBodies.begin(); it != m_pDynSys->m_SimBodies.end(); it++){
//        LOG(m_pSimulationLog, "RigidBody Id: " << (*it)->m_id << std::endl;)
//    }



    if(m_pTimestepper->m_Settings.m_eSimulateFromReference == TimeStepperSettings::NONE) {
        m_pStateRecorder->write(m_pTimestepper->getTimeCurrent(),m_pDynSys->m_SimBodies);
    }


    PREC runtime;
    m_globalTimer.start();

    while(1){

        // Do one iteration
        m_pTimestepper->doOneIteration();


        writeAllOutput();

        // Check if simulation can be aborted!
        if(m_pTimestepper->finished()) {
            runtime = ((PREC)m_globalTimer.elapsed())*1e-9;
            LOG(m_pSimulationLog, "---> SimulationManager: Timestepper finished, needed: " << runtime << " sec. , exit..."<< std::endl );
            break;
        }
    }

    m_pTimestepper->closeAllFiles();
    m_pStateRecorder->closeAll();

    // MPI Communicat times, get the max runtime
    getMaxRuntime(runtime);


m_pSimulationLog->logMessage("---> SimulationManager: Simulation leaving...");
return;
}


void SimulationManagerMPI::writeAllOutput() {

    if(m_RecorderSettings.outputCheck(m_pTimestepper->getIterationCount())) {
        // Write Data to SystemDataFile (maps all data to back buffer!)
        m_pTimestepper->writeIterationToSystemDataFile((PREC)m_globalTimer.elapsed()*1e-9);
        // Write Data to CollisionDataFile
        //m_pTimestepper->writeIterationToCollisionDataFile();
        // Write  State to Sim File
        //m_pStateRecorder->write(m_pTimestepper->getFrontStateBuffer().get());

        // if the recorder would support parallel write , interleaving the calculation we could
        // wait here for the recorder to finish up
        // m_pStateRecorder->wait(); // waits till the recorder has finished its parallel stuff

        m_pStateRecorder->write(m_pTimestepper->getTimeCurrent(), m_pDynSys->m_SimBodies);
        // this would then be asynchronous call (copies states internally and writes everything out
    }
}


void SimulationManagerMPI::initSim() {


    MPILayer::GenericMessage1<boost::filesystem::path> message;

    if(m_pProcCommunicator->hasMasterRank()) { // Only master process
        // Get new sim folder path relative to global directory

        m_SimFolderPath = FileManager::getSingletonPtr()->getNewSimFolderPath(SIMULATION_FOLDER_PATH,SIM_FOLDER_PREFIX_RECORD);

        LOG(m_pSimulationLog,"MPI> Broadcast new simulation directory: "<< m_SimFolderPath <<std::endl;);

        boost::filesystem::path sceneFilePath = m_SimFolderPath;
        std::string filename = SIM_SCENE_FILE_NAME;
        filename += ".xml";
        sceneFilePath /= filename;

        LOG(m_pSimulationLog,"---> Copy parsed scene file to: " << sceneFilePath <<std::endl;)
        FileManager::getSingletonPtr()->copyFile(m_pSceneParser->getParsedSceneFile(),sceneFilePath,true);

        // Need to broadcast the filename of the actual folder
        // Broadcast: m_SimFolderPath

        message.m_data.get<0>() = m_SimFolderPath;

        m_pProcCommunicator->sendBroadcast(message);
    } else { // All other processes

        m_pProcCommunicator->receiveBroadcast(message, m_pProcCommunicator->getMasterRank());
        m_SimFolderPath = message.m_data.get<0>();
        LOG(m_pSimulationLog,"MPI> Received new simulation directory: "<< m_SimFolderPath <<std::endl;);
    }

    // Create same folder name in Local Process Directory, to save all data...
    boost::filesystem::path localSimFolderPath = FileManager::getSingletonPtr()->getLocalDirectoryPath();
    localSimFolderPath /= m_SimFolderPath.filename();
    if(!boost::filesystem::create_directories(localSimFolderPath)) {
        LOG(m_pSimulationLog,  "ERROR:---> Could not create directory: " << localSimFolderPath.string() << std::endl;);
        ERRORMSG("ERROR:---> Could not create directory: " << localSimFolderPath.string() << std::endl )
    }


    m_pStateRecorder->setDirectoryPath(m_SimFolderPath); // If StateRecorder is StateRecorderBody or StateRecorderMPI
    //m_pStateRecorder->setDirectoryPath(localSimFolderPath);

// Uncomment if StateRecorder is StateRecorderBody
//    if(!m_pStateRecorder->createSimFiles(m_pDynSys->m_SimBodies,true)) { // Truncate the files, important!
//        LOG(m_pSimulationLog,  "ERROR:---> Could not open all SimFiles: " << m_SimFolderPath.string() << std::endl;);
//        ERRORMSG("ERROR:---> Could not open all SimFiles: " << m_SimFolderPath.string() << std::endl)
//    }

    if(!m_pStateRecorder->createSimFile(true)) { // Truncate the files, important!
        LOG(m_pSimulationLog,  "ERROR:---> Could not open SimFilePart: " << localSimFolderPath.string() << std::endl;);
        ERRORMSG("ERROR:---> Could not open SimFilePart: " << localSimFolderPath.string() << std::endl)
    }
// ===============================================


    m_pTimestepper->initLogs(localSimFolderPath);

    // Get the actual RecorderSettings
    m_pDynSys->getSettings(m_RecorderSettings);


    m_pTimestepper->reset();

}
