#include <fstream>

#define _USE_MATH_DEFINES
#include <cmath>

#include <memory>

#include "TypeDefs.hpp"
#include "LogDefines.hpp"
#include "AssertionDebug.hpp"

#include "SharedBufferDynSys.hpp"
#include "StateRecorder.hpp"
#include "StateRecorderBody.hpp"
#include "StateRecorderProcess.hpp"
#include "StateRecorderMPI.hpp"

#include TimeStepper_INCLUDE_FILE
#include DynamicsSystem_INCLUDE_FILE

#include "CommonFunctions.hpp"
#include "QuaternionHelpers.hpp"

#include "FileManager.hpp"

#include "MPIMessages.hpp"
#include "MPICommunication.hpp"

#include "MPITopologyBuilder.hpp"


SimulationManagerMPI::SimulationManagerMPI() {

}

SimulationManagerMPI::~SimulationManagerMPI() {
    DECONSTRUCTOR_MESSAGE

}


void SimulationManagerMPI::setup() {
    setup("SceneFile.xml");
}


void SimulationManagerMPI::setup(boost::filesystem::path sceneFilePath) {

    //Each Process copies its SceneFile.xml to the folders, that each Process can read its own file (better)
    boost::filesystem::path sceneFilePathNew = FileManager::getSingletonPtr()->copyFile(sceneFilePath,
            FileManager::getSingletonPtr()->getLocalDirectoryPath());

    //Make log!
    m_pSimulationLog = nullptr;
    if(Logging::LogManager::getSingletonPtr()->existsLog("SimulationLog")) {
        m_pSimulationLog = Logging::LogManager::getSingletonPtr()->getLog("SimulationLog");
    } else {
        boost::filesystem::path filePath = FileManager::getSingletonPtr()->getLocalDirectoryPath();
        filePath /= GLOBAL_LOG_FOLDER_DIRECTORY;
        filePath /= "SimulationLog.log";
        m_pSimulationLog = Logging::LogManager::getSingletonPtr()->createLog("SimulationLog",SIMULATION_LOG_TO_CONSOLE,true,filePath);
    }

    m_pSimulationLog->logMessage("---> SimulationManagerMPI::setup(): ");

    // MPI Process Commnunicator

    m_pProcCommunicator = std::shared_ptr<ProcessCommunicatorType >(new ProcessCommunicatorType(
                                                    MPILayer::MPIGlobalCommunicators::getSingletonPtr()->getCommunicator(
                                                      MPILayer::MPICommunicatorId::SIM_COMM
                                                    )
                                           ));
    m_pSimulationLog->logMessage("---> SimulationManagerMPI:: Added ProcessCommunicator");


    m_pDynSys = std::shared_ptr< DynamicsSystemType >( new DynamicsSystemType());
    m_pSimulationLog->logMessage("---> SimulationManagerMPI:: Added DynamicsSystem");

    // Parse the SceneSettings only ==========================
    m_pSceneParser = std::shared_ptr< SceneParserType >( new SceneParserType( *m_pDynSys) );
    m_pSimulationLog->logMessage("---> SimulationManagerMPI:: Added SceneParser and parse Scene");

    {
        typename SceneParserType::BodyModuleOptionsType optBody;
        optBody.m_parseAllBodiesNonSelGroup = true;
        optBody.m_parseSimBodies = false; optBody.m_allocateSimBodies = false;
        optBody.m_parseStaticBodies = true; optBody.m_allocateStaticBodies = true;

        SceneParserType::SceneParserOptionsType optScene;
        optScene.m_parseSceneSettings = true;
        optScene.m_parseSceneObjects = true;

        m_pSceneParser->parseScene(sceneFilePathNew, typename SceneParserType::SceneParserOptionsType(), std::move(optBody)) ;
    }

    m_nGlobalSimBodies = m_pSceneParser->getSpecifiedSimBodies();
    LOG(m_pSimulationLog,  "---> Scene parsing finshed: Added "<< m_pDynSys->m_simBodies.size()
        << " simulated & " << m_pDynSys->m_staticBodies.size()<<  " static bodies! "  << std::endl;);
    LOG(m_pSimulationLog,  "---> SimulationManagerMPI:: Global Bodies in Simulation "<< m_nGlobalSimBodies<< " Bodies!" << std::endl;);
    // ====================================================

    // TopologyBuilder Build Topology =====================

    if(m_pDynSys->getSettingsTopoBuilder().m_type == MPILayer::TopologyBuilderEnum::GRIDBUILDER){

        m_pTopologyBuilder = std::shared_ptr< TopologyBuilderType >(
                                                new MPILayer::GridTopologyBuilder<SceneParserType, ProcessCommunicatorType>
                                                  (m_pDynSys,m_pProcCommunicator, m_pDynSys->getSettingsTopoBuilder().m_gridBuilderSettings
                                                   ,sceneFilePathNew, m_nGlobalSimBodies ) );
    }else{
        ERRORMSG("No Topology Builder type instantiated")
    }

    m_pTopologyBuilder->initTopology();

    // Parse the scene objects from the XML, but selectively on the ids in m_pDynSys->bodiesInitStates
    {
        typename SceneParserType::BodyModuleOptionsType optBody;
        optBody.m_parseAllBodiesNonSelGroup = true;
        optBody.m_parseSimBodies = true; optBody.m_allocateSimBodies = true;
        optBody.m_parseStaticBodies = false; optBody.m_allocateStaticBodies = false;
        optBody.m_parseInitialCondition = false;
        optBody.m_parseAllIfRangeEmpty = false;

        SceneParserType::SceneParserOptionsType optScene;
        optScene.m_parseSceneSettings = false;
        optScene.m_parseSceneObjects = true;

        std::set<RigidBodyIdType> bodiesToload;
        for(auto & s: m_pDynSys->m_bodiesInitStates){ bodiesToload.insert(s.second.m_id);}
        optBody.m_bodyIdRange = std::move(bodiesToload);

        m_pSceneParser->parseScene(sceneFilePathNew, optScene , std::move(optBody));

        // Apply initial states (received from master) to bodies
        m_pDynSys->applyInitStatesToBodies();

        LOG(m_pSimulationLog,  "---> Scene parsing finshed: Added "<< m_pDynSys->m_simBodies.size()
        << " simulated & " << m_pDynSys->m_staticBodies.size()<<  " static bodies! "  << std::endl;);
    }

    //=====================================================


    // Do Safty Check
    // Do a Reduction of all Simbodies, to count if no bodies are missing!
    m_pSimulationLog->logMessage("---> Check number of Bodies in Process:");
    checkNumberOfBodiesInProcess();

    // =====================================================

    //Uncomment if StateRecorderType = StateRecorderBodys
    //m_pStateRecorder  =  std::shared_ptr<StateRecorderType >(new StateRecorderType(true,m_pProcCommunicator->getProcInfo()->getRank()));

    m_pStateRecorder  =  std::shared_ptr<StateRecorderType >(new StateRecorderType(m_nGlobalSimBodies,
                                                                std::static_pointer_cast<ProcessCommunicatorType::ProcessInfoType>(m_pProcCommunicator)));
    // =====================================================


    //Uncomment if StateRecorderType = StateRecorderBodys
    //Set up delegate function from BodyCommunicator to StateRecorederBody (close and open files)
    //        m_pBodyCommunicator->addDelegateLocalRemove(
    //            BodyCommunicator<DynamicsSystemType>::AddDelegate::template
    //            from_method< StateRecorderType,&StateRecorderType::removeBody>
    //            (& *m_pStateRecorder.get())
    //        );
    //        m_pBodyCommunicator->addDelegateLocalAdd(
    //            BodyCommunicator<DynamicsSystemType>::AddDelegate::template
    //            from_method< StateRecorderType,&StateRecorderType::addBody>
    //            (& *m_pStateRecorder.get())
    //        );
    // TODO: Danger shared_ptr.get() in delegate class,
    //as along as there is the SimMgrMpi there is a NbCommunicator and a StatRecorder, so no problem
    // ===============================================

    m_pTimestepper = std::shared_ptr< TimeStepperType >( new TimeStepperType(m_pDynSys, m_pProcCommunicator) );

    m_pSimulationLog->logMessage("---> Initialize ProcessCommunicator buffers...");
    m_pProcCommunicator->initializeNeighbourBuffers();

    m_pSimulationLog->logMessage("---> SimulationManagerMPI::setup() finished!");
}



void SimulationManagerMPI::checkNumberOfBodiesInProcess() {

    int numberOfBodiesInSimulation = 0;
    int nSimBodies = m_pDynSys->m_simBodies.size();

    CPUTimer timer;

    timer.start();
    LOG(m_pSimulationLog,  "MPI> Body check,  MPI_Reduce... "<< std::endl;)
    MPI_Reduce(&nSimBodies,&numberOfBodiesInSimulation, 1, MPI_INT, MPI_SUM, m_pProcCommunicator->getMasterRank(), m_pProcCommunicator->getCommunicator());
    double elapsed = timer.elapsedSec();

    if(m_pProcCommunicator->hasMasterRank()) {
        LOG(m_pSimulationLog,  "MPI> Allreduce needed: " << elapsed <<"sec."<<std::endl; );

        if(numberOfBodiesInSimulation != m_nGlobalSimBodies) {
            LOG(m_pSimulationLog,  "ERROR:---> Body check NOT successful! : "<< numberOfBodiesInSimulation <<"!="<< m_nGlobalSimBodies<< std::endl;);
            ERRORMSG("Body check Not successfull");
        }

        LOG(m_pSimulationLog,  "---> Body check successfull!: "<<numberOfBodiesInSimulation<<" SimBodies in Simulation" << std::endl;);
    } else {
        LOG(m_pSimulationLog,  "---> Body check ... (sent # of bodies) !"<< std::endl;);
    }

}


void SimulationManagerMPI::getMaxRuntime(PREC runtime){

    LOG(m_pSimulationLog,  "MPI> Get Max Runtime,  MPI_Reduce... "<< std::endl;);
    PREC maxRuntime;

    MPI_Reduce(&runtime,&maxRuntime, 1, MPI_DOUBLE, MPI_MAX, m_pProcCommunicator->getMasterRank(), m_pProcCommunicator->getCommunicator());

    if(m_pProcCommunicator->hasMasterRank()){
        LOG(m_pSimulationLog, "---> Total runtime for simulation needed: "<<maxRuntime<< " sec. " << std::endl;);
    }else{
        LOG(m_pSimulationLog, "---> Runtime sent ... !"<< std::endl;);
    }


}



void SimulationManagerMPI::startSim() {



    static double timelineSimulation;

    m_pSimulationLog->logMessage("---> SimulationManager: Simulation entering...");

    initSim();

    if(m_pTimestepper->m_settings.m_eSimulateFromReference == TimeStepperSettings::NONE) {
        m_pStateRecorder->write(m_pTimestepper->getTimeCurrent(),m_pDynSys->m_simBodies);
    }


    PREC runtime;
    m_globalTimer.start();

    while(1){

        // Do one iteration
        m_pTimestepper->doOneIteration();

        writeAllOutput();

        // Check if simulation can be aborted!
        if(m_pTimestepper->finished()) {
            runtime = m_globalTimer.elapsedSec();
            LOG(m_pSimulationLog, "---> SimulationManager: Timestepper finished, needed: " << runtime << " sec. , exit..."<< std::endl );
            break;
        }
    }

    m_pTimestepper->closeAllFiles();
    m_pStateRecorder->closeAll();

    // MPI Communicat times, get the max runtime
    getMaxRuntime(runtime);


m_pSimulationLog->logMessage("---> SimulationManager: Simulation leaving...");
return;
}


void SimulationManagerMPI::writeAllOutput() {

    if(m_RecorderSettings.outputCheck(m_pTimestepper->getIterationCount())) {
        // Write Data to SystemDataFile (maps all data to back buffer!)
        m_pTimestepper->writeIterationToSystemDataFile(m_globalTimer.elapsedSec());
        // Write Data to CollisionDataFile
        //m_pTimestepper->writeIterationToCollisionDataFile();
        // Write  State to Sim File
        //m_pStateRecorder->write(m_pTimestepper->getFrontStateBuffer().get());

        // if the recorder would support parallel write , interleaving the calculation we could
        // wait here for the recorder to finish up
        // m_pStateRecorder->wait(); // waits till the recorder has finished its parallel stuff

        m_pStateRecorder->write(m_pTimestepper->getTimeCurrent(), m_pDynSys->m_simBodies);
        // this would then be asynchronous call (copies states internally and writes everything out
    }
}


void SimulationManagerMPI::initSim() {


    MPILayer::GenericMessage1<boost::filesystem::path> message;

    if(m_pProcCommunicator->hasMasterRank()) { // Only master process
        // Get new sim folder path relative to global directory

        m_SimFolderPath = FileManager::getSingletonPtr()->getNewSimFolderPath(SIMULATION_FOLDER_PATH,SIM_FOLDER_PREFIX_RECORD);

        LOG(m_pSimulationLog,"MPI> Broadcast new simulation directory: "<< m_SimFolderPath <<std::endl;);

        boost::filesystem::path sceneFilePath = m_SimFolderPath;
        std::string filename = SIM_SCENE_FILE_NAME;
        filename += ".xml";
        sceneFilePath /= filename;

        LOG(m_pSimulationLog,"---> Copy parsed scene file to: " << sceneFilePath <<std::endl;)
        FileManager::getSingletonPtr()->copyFile(m_pSceneParser->getParsedSceneFile(),sceneFilePath,true);

        // Need to broadcast the filename of the actual folder
        // Broadcast: m_SimFolderPath

        message.m_data.get<0>() = m_SimFolderPath;

        m_pProcCommunicator->sendBroadcast(message);
    } else { // All other processes

        m_pProcCommunicator->receiveBroadcast(message, m_pProcCommunicator->getMasterRank());
        m_SimFolderPath = message.m_data.get<0>();
        LOG(m_pSimulationLog,"MPI> Received new simulation directory: "<< m_SimFolderPath <<std::endl;);
    }

    // Create same folder name in Local Process Directory, to save all data...
    boost::filesystem::path localSimFolderPath = FileManager::getSingletonPtr()->getLocalDirectoryPath();
    localSimFolderPath /= m_SimFolderPath.filename();
    if(!boost::filesystem::create_directories(localSimFolderPath)) {
        LOG(m_pSimulationLog,  "ERROR:---> Could not create directory: " << localSimFolderPath.string() << std::endl;);
        ERRORMSG("ERROR:---> Could not create directory: " << localSimFolderPath.string() << std::endl )
    }


    m_pStateRecorder->setDirectoryPath(m_SimFolderPath); // If StateRecorder is StateRecorderBody or StateRecorderMPI
    //m_pStateRecorder->setDirectoryPath(localSimFolderPath);

// Uncomment if StateRecorder is StateRecorderBody
//    if(!m_pStateRecorder->createSimFiles(m_pDynSys->m_simBodies,true)) { // Truncate the files, important!
//        LOG(m_pSimulationLog,  "ERROR:---> Could not open all SimFiles: " << m_SimFolderPath.string() << std::endl;);
//        ERRORMSG("ERROR:---> Could not open all SimFiles: " << m_SimFolderPath.string() << std::endl)
//    }

    if(!m_pStateRecorder->createSimFile(true)) { // Truncate the files, important!
        LOG(m_pSimulationLog,  "ERROR:---> Could not open SimFilePart: " << localSimFolderPath.string() << std::endl;);
        ERRORMSG("ERROR:---> Could not open SimFilePart: " << localSimFolderPath.string() << std::endl)
    }
// ===============================================

    m_pTimestepper->reset();
    m_pTimestepper->initLogs(localSimFolderPath);

    // Get the actual RecorderSettings
    m_RecorderSettings = m_pDynSys->getSettingsRecorder();




}
