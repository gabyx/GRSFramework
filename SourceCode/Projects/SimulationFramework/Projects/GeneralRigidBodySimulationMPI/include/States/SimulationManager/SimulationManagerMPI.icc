#include <fstream>

#define _USE_MATH_DEFINES
#include <cmath>

#include "TypeDefs.hpp"
#include "LogDefines.hpp"
#include "AssertionDebug.hpp"

#include "DynamicsState.hpp"
#include "SharedBufferDynSys.hpp"
#include "StateRecorder.hpp"
#include "StateRecorderBody.hpp"

#include "MoreauTimeStepperMPI.hpp"
#include "DynamicsSystemMPI.hpp"

#include "CommonFunctions.hpp"
#include "QuaternionHelpers.hpp"

#include "FileManager.hpp"

#include "MPIMessages.hpp"
#include "MPICommunication.hpp"


using namespace std;



template<typename TConfig>
SimulationManagerMPI<TConfig>::SimulationManagerMPI() {

}
template<typename TConfig>
SimulationManagerMPI<TConfig>::~SimulationManagerMPI() {
    DECONSTRUCTOR_MESSAGE

}

template<typename TConfig>
void SimulationManagerMPI<TConfig>::setup() {
    setup("SceneFile.xml");
}

template<typename TConfig>
void SimulationManagerMPI<TConfig>::setup(boost::filesystem::path sceneFilePath) {

    //Each Process copies its SceneFile.xml to the folders, that each Process can read its own file (better)
    boost::filesystem::path sceneFilePathNew = FileManager::getSingletonPtr()->copyFile(sceneFilePath,
            FileManager::getSingletonPtr()->getLocalDirectoryPath());

    //Make log!
    m_pSimulationLog = NULL;
    if(Logging::LogManager::getSingletonPtr()->existsLog("SimulationLog")) {
        m_pSimulationLog = Logging::LogManager::getSingletonPtr()->getLog("SimulationLog");
    } else {
        boost::filesystem::path filePath = FileManager::getSingletonPtr()->getLocalDirectoryPath();
        filePath /= GLOBAL_LOG_FOLDER_DIRECTORY;
        filePath /= "SimulationLog.log";
        m_pSimulationLog = Logging::LogManager::getSingletonPtr()->createLog("SimulationLog",true,true,filePath);
    }

    m_pSimulationLog->logMessage("---> SimulationManagerMPI::setup(): ");

    // MPI Process Commnunicator

    m_pProcCommunicator = boost::shared_ptr<MPILayer::ProcessCommunicator<DynamicsSystemType> >(new MPILayer::ProcessCommunicator<DynamicsSystemType>());
    m_pSimulationLog->logMessage("--->SimulationManagerMPI:: Added ProcessCommunicator");


    m_pDynSys = boost::shared_ptr< DynamicsSystemType >( new DynamicsSystemType());
    m_pSimulationLog->logMessage("--->SimulationManagerMPI:: Added DynamicsSystem");

    // Parse the Scene from XML! ==========================

    m_pSceneParser = boost::shared_ptr< SceneParserMPI<TConfig> >( new SceneParserMPI<TConfig>( m_pDynSys, m_pProcCommunicator ) );
    m_pSimulationLog->logMessage("---> SimulationManagerMPI:: Added SceneParser and parse Scene");
    m_pSceneParser->parseScene(sceneFilePathNew);
    m_nGlobalSimBodies = m_pSceneParser->getNumberOfGlobalSimBodies();
    m_nSimBodies = m_pSceneParser->getNumberOfSimBodies();
    LOG(m_pSimulationLog,  "---> SimulationManagerMPI:: SceneParsing finshed: Added "<< m_nSimBodies << " Bodies!" << std::endl;);
    LOG(m_pSimulationLog,  "---> SimulationManagerMPI:: Global Bodies in Simulation "<< m_nGlobalSimBodies<< " Bodies!" << std::endl;);

    // Do Safty Check
    // Do a Reduction of all Simbodies, to count if no bodies are missing!
    m_pSimulationLog->logMessage("---> Check number of Bodies in Process:");
    m_nSimBodies = m_pSceneParser->getNumberOfSimBodies();
    checkNumberOfBodiesInProcess();

    // =====================================================

    m_pStateRecorder = boost::shared_ptr<StateRecorderBody<DynamicsSystemType> >(new StateRecorderBody<DynamicsSystemType>());

    m_pNbCommunicator = boost::shared_ptr<NeighbourCommunicator<DynamicsSystemType> >(
                            new NeighbourCommunicator<DynamicsSystemType>(m_pDynSys->m_SimBodies, m_pDynSys->m_RemoteSimBodies, m_pDynSys->m_globalGeoms,  m_pProcCommunicator) );

    //Set up delegate function from NeighbourCommunicator to StateRecorederBody (close and open files)
    m_pNbCommunicator->addDelegateLocalRemove(
        NeighbourCommunicator<DynamicsSystemType>::AddDelegate::template
        from_method< StateRecorderBody<DynamicsSystemType>,&StateRecorderBody<DynamicsSystemType>::removeBody>
        (& *m_pStateRecorder.get())
    );
    m_pNbCommunicator->addDelegateLocalAdd(
        NeighbourCommunicator<DynamicsSystemType>::AddDelegate::template
        from_method< StateRecorderBody<DynamicsSystemType>,&StateRecorderBody<DynamicsSystemType>::addBody>
        (& *m_pStateRecorder.get())
    );
    // TODO: Danger shared_ptr.get() in delegate class,
    //as along as there is the SimMgrMpi there is a NbCommunicator and a StatRecorder, so no problem

    m_pTimestepper = boost::shared_ptr< TimeStepperType >( new TimeStepperType(m_pDynSys, m_pProcCommunicator, m_pNbCommunicator) );





    m_pSimulationLog->logMessage("---> SimulationManagerMPI::setup() finished!");
}


template<typename TConfig>
bool SimulationManagerMPI<TConfig>::checkNumberOfBodiesInProcess() {

    int numberOfBodiesInSimulation = 0;
    int nSimBodies = m_nSimBodies;

    boost::timer::cpu_timer timer;

    timer.start();
    LOG(m_pSimulationLog,  "MPI> Body check,  MPI_Reduce... "<< std::endl;);
    MPI_Reduce(&nSimBodies,&numberOfBodiesInSimulation, 1, MPI_INT, MPI_SUM, ProcessInfoType::MASTER_RANK, MPI_COMM_WORLD);
    timer.stop();
    double elapsed = ((double)timer.elapsed().wall)*1e-9;

    if(m_pProcCommunicator->getProcInfo()->hasMasterRank()) {
        LOG(m_pSimulationLog,  "MPI> Allreduce needed: " << elapsed <<"sec."<<std::endl; );

        if(numberOfBodiesInSimulation != m_nGlobalSimBodies) {
            LOG(m_pSimulationLog,  "ERROR:---> Body check NOT successful! : "<< numberOfBodiesInSimulation <<"!="<< m_nGlobalSimBodies<< std::endl;);
            ERRORMSG("Body check Not successfull");
        }

        LOG(m_pSimulationLog,  "---> Body check successfull!: "<<numberOfBodiesInSimulation<<" SimBodies in Simulation" << std::endl;);
    } else {
        LOG(m_pSimulationLog,  "---> Body check ... (sent # of bodies) !"<< std::endl;);
    }

}

template<typename TConfig>
void SimulationManagerMPI<TConfig>::startSim() {

    static double timelineSimulation;

    m_pSimulationLog->logMessage("---> SimulationManager: Simulation entering...");

    initSim();


    //Write first initial value out!
    if(m_pTimestepper->m_Settings.m_eSimulateFromReference == TimeStepperSettings<LayoutConfigType>::NONE) {
        m_pStateRecorder->writeStates(m_pDynSys->m_SimBodies);
    }


//
    while(1){

        // Do one iteration
        m_pTimestepper->doOneIteration();
        //m_pTimestepper->doOneIteration();
//      // get global time for logging!
//      timelineSimulation = ((double)global_time.elapsed().wall)*1e-9;
//      // Write Data to SystemDataFile (maps all data to back buffer!)
//      m_pTimestepper->writeIterationToSystemDataFile(timelineSimulation);
//      // Write Data to CollisionDataFile
//      m_pTimestepper->writeIterationToCollisionDataFile();
        // Write  State to Sim File
        m_pStateRecorder->writeStates(m_pDynSys->m_SimBodies);

        // Check if simulation can be aborted!
        if(m_pTimestepper->finished()) {
            m_pSimulationLog->logMessage("---> SimulationManager: Timestepper finished, exit...");
            break;
        }
    }

m_pSimulationLog->logMessage("---> SimulationManager: Simulation leaving...");
return;
}

template<typename TConfig>
void SimulationManagerMPI<TConfig>::initSim() {


    MPILayer::GenericMessage1<boost::filesystem::path> message;

    if(m_pProcCommunicator->getProcInfo()->hasMasterRank()) { // Only master process
        // Get new sim folder path relative to global directory

        m_SimFolderPath = FileManager::getSingletonPtr()->getNewSimFolderPath(SIMULATION_FOLDER_PATH,SIM_FOLDER_PREFIX_RECORD);

        LOG(m_pSimulationLog,"MPI> Broadcast new simulation directory: "<< m_SimFolderPath <<std::endl;);

        boost::filesystem::path sceneFilePath = m_SimFolderPath;
        std::string filename = SIM_SCENE_FILE_NAME;
        filename += ".xml";
        sceneFilePath /= filename;

        LOG(m_pSimulationLog,"---> Copy parsed scene file to: " << sceneFilePath <<std::endl;)
        FileManager::getSingletonPtr()->copyFile(m_pSceneParser->getParsedSceneFile(),sceneFilePath,true);

        // Need to broadcast the filename of the actual folder
        // Broadcast: m_SimFolderPath

        message.m_data.get<0>() = m_SimFolderPath;

        m_pProcCommunicator->sendBroadcast(message, MPI_COMM_WORLD);
    } else { // All other processes

        m_pProcCommunicator->receiveBroadcast(message, m_pProcCommunicator->getProcInfo()->getMasterRank(), MPI_COMM_WORLD);
        m_SimFolderPath = message.m_data.get<0>();
        LOG(m_pSimulationLog,"MPI> Received new simulation directory: "<< m_SimFolderPath <<std::endl;);
    }

    // Create same folder name in Local Process Directory, to save all data...
    boost::filesystem::path localSimFolderPath = FileManager::getSingletonPtr()->getLocalDirectoryPath();
    localSimFolderPath /= m_SimFolderPath.filename();
    if(!boost::filesystem::create_directories(localSimFolderPath)) {
        LOG(m_pSimulationLog,  "ERROR:---> Could not create directory: " << localSimFolderPath.string() << std::endl;);
        ERRORMSG("ERROR:---> Could not create directory: " << localSimFolderPath.string() << std::endl )
    }


    m_pStateRecorder->setDirectoryPath(m_SimFolderPath);
    if(!m_pStateRecorder->openFiles(m_pDynSys->m_SimBodies,true)) { // Truncate the files, important!
        LOG(m_pSimulationLog,  "ERROR:---> Could not open all SimFiles: " << m_SimFolderPath.string() << std::endl;);
        ERRORMSG("ERROR:---> Could not open all SimFiles: " << m_SimFolderPath.string() << std::endl)
    }

    m_pTimestepper->initLogs(localSimFolderPath);

    m_pTimestepper->reset();

}
