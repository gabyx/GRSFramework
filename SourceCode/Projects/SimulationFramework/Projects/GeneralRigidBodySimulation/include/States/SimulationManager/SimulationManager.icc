
#include <fstream>

#define _USE_MATH_DEFINES
#include <cmath>

#include "LogDefines.hpp"
#include "AssertionDebug.hpp"

#include <RenderContext.hpp>

#include "DynamicsState.hpp"
#include "SharedBufferDynSys.hpp"
#include "StateRecorder.hpp"
#include "MoreauTimeStepper.hpp"
#include "InclusionSolverNT.hpp"
#include "InclusionSolverCO.hpp"
#include "InclusionSolverCONoG.hpp"

#include "DynamicsSystem.hpp"

#include "CommonFunctions.hpp"
#include "QuaternionHelpers.hpp"

#include "FileManager.hpp"


using namespace std;



template<typename TConfig>
SimulationManager<TConfig>::SimulationManager():
SimulationManagerBase()
{

  boost::filesystem::path filePath = GLOBAL_LOG_FOLDER_DIRECTORY;
  filePath /= "SimulationLog.log";
  m_pSimulationLog = Logging::LogManager::getSingletonPtr()->createLog("SimulationLog",true,true,filePath);
  m_pSimulationLog->logMessage("Creating SimulationManager...");



  m_KeyListenerName = "SimulationManager::KeyListener";

}
template<typename TConfig>
SimulationManager<TConfig>::~SimulationManager()
{
  DECONSTRUCTOR_MESSAGE

}
template<typename TConfig>
void SimulationManager<TConfig>::setup()
{


  m_pSimulationLog->logMessage("---> SimulationManager::setup(): ");


  m_pDynSys = boost::shared_ptr< DynamicsSystemType >( new DynamicsSystemType());

  // Parse the Scene from XML! ==========================
  m_pSceneParser = boost::shared_ptr< SceneParser<TConfig> >( new SceneParser<TConfig>( m_pDynSys) );
  m_pSceneParser->parseScene("SceneFile.xml");

  m_nSimBodies = m_pSceneParser->getNumberOfSimBodies();
  // =====================================================


  m_pSharedBuffer = boost::shared_ptr<SharedBufferDynSys<LayoutConfigType> >(new SharedBufferDynSys<LayoutConfigType>(m_nSimBodies));
  m_pTimestepper = boost::shared_ptr< TimeStepperType >( new TimeStepperType(m_nSimBodies, m_pDynSys, m_pSharedBuffer) );

  m_pVisBuffer = m_pSharedBuffer->updateVisBuffer();

  m_pStateRecorder = boost::shared_ptr<StateRecorder<LayoutConfigType> >(new StateRecorder<LayoutConfigType>(m_nSimBodies));


  m_pSharedBuffer->initializeStatePool(m_pSceneParser->getInitialConditionSimBodies());
  m_pVisBuffer = m_pSharedBuffer->updateVisBuffer();

  m_pSimulationLog->logMessage("---> added all objects(): ");
}


template<typename TConfig>
bool SimulationManager<TConfig>::writeInitialState(){
   MultiBodySimFile<LayoutConfigType> simFile;
   // Request new file Paths for all logs from FileManager
   // Get new folder path
   boost::filesystem::path file = FileManager::getSingletonPtr()->getNewSimFolderPath(SIMULATION_FOLDER_PATH,SIM_FOLDER_PREFIX_INIT);

   std::string filename = SIM_INIT_FILE_PREFIX;
   filename += SIM_INIT_FILE_EXTENSION;
   file /= filename;
   if(simFile.openSimFileWrite(file,m_nSimBodies)){
      simFile << m_pVisBuffer.get();
      simFile.closeSimFile();
      m_pSimulationLog->logMessage(std::string("Successfully written initial state file to:") + file.string() );
      return true;
   }
    m_pSimulationLog->logMessage(std::string("Error while trying to open and write initial state file to:") + file.string() );
   return false;
}


template<typename TConfig>
void SimulationManager<TConfig>::initBeforeThreads()
{

}


template<typename TConfig>
void SimulationManager<TConfig>::threadRunRecord()
{

  static double timelineSimulation;

  m_pSimulationLog->logMessage(" SimulationManager: RecordThread entering...");
  setSimThreadRunning(true);


  initRecordThread();

  //Reset Timestepper!
   m_pTimestepper->reset();

  //Open File
  bool fileOK = false;
  if(m_pTimestepper->m_Settings.m_eSimulateFromReference == TimeStepperSettings<LayoutConfigType>::CONTINUE){
      fileOK = m_pStateRecorder->createSimFileCopyFromReference(m_SimFilePath,m_pTimestepper->m_Settings.m_stateReferenceFile);
  }else{
      fileOK = m_pStateRecorder->createSimFile(m_SimFilePath);
  }
  m_pSimulationLog->logMessage("after file");

  if(fileOK)
  {

    // Write first initial value out!
    if(m_pTimestepper->m_Settings.m_eSimulateFromReference == TimeStepperSettings<LayoutConfigType>::NONE){
      m_pStateRecorder->write(m_pTimestepper->getFrontStateBuffer().get());
    }
    m_pSimulationLog->logMessage("after");
    // wait for vis thread! (which does some loops before)

    resetTimelineSimulation();

    while(!isSimThreadToBeStopped())
    {


      // Read all inputs
      readSharedBuffer();
      // Do one iteration
      m_pTimestepper->doOneIteration();
      // Write outputs
      writeSharedBuffer();

      // get global time for logging!
      timelineSimulation = getTimelineSimulation();
      // Write Data to SystemDataFile (maps all data to back buffer!)
      m_pTimestepper->writeIterationToSystemDataFile(timelineSimulation);
      // Write Data to CollisionDataFile
      m_pTimestepper->writeIterationToCollisionDataFile();
      // Write  State to Sim File
      m_pStateRecorder->write(m_pTimestepper->getFrontStateBuffer().get());

      // Check if simulation can be aborted!
      if(m_pTimestepper->finished()){
         m_pSimulationLog->logMessage(" SimulationManager: Timestepper finished, exit...");
         break;
      }
    }

    cleanUpRecordThread();
  }

  setSimThreadRunning(false);
  m_pSimulationLog->logMessage(" SimulationManager: RecordThread leaving...");
  return;
}
template<typename TConfig>
void SimulationManager<TConfig>::initRecordThread()
{
  // Get new folder path
  m_SimFolderPath = FileManager::getSingletonPtr()->getNewSimFolderPath(SIMULATION_FOLDER_PATH,SIM_FOLDER_PREFIX_RECORD);

   // Sim file path
     m_SimFilePath = m_SimFolderPath;
     std::string filename = SIM_FILE_PREFIX;
     filename += SIM_FILE_EXTENSION;
     m_SimFilePath /= filename;

   boost::filesystem::path m_SceneFilePath = m_SimFolderPath;
   filename = SIM_SCENE_FILE_NAME;
   filename += ".xml";
   m_SceneFilePath /= filename;

   FileManager::getSingletonPtr()->copyFile(m_pSceneParser->getCurrentSceneFilePath(),m_SceneFilePath,true);

  m_pTimestepper->initLogs(m_SimFolderPath);

}
template<typename TConfig>
void SimulationManager<TConfig>::cleanUpRecordThread(){
   m_pTimestepper->closeAllFiles();
   m_pStateRecorder->closeSimFile();
}


template<typename TConfig>
void SimulationManager<TConfig>::readSharedBuffer(){

}

template<typename TConfig>
void SimulationManager<TConfig>::writeSharedBuffer(){
  static int iterations = 0;
  iterations++;

  //if(iterations%100==0){
    setIterationTime(m_pTimestepper->m_AvgTimeForOneIteration, m_pTimestepper->m_MaxTimeForOneIteration);
    setNumberOfContacts(m_pTimestepper->m_pInclusionSolver->m_nContacts);

  //}

}

template<typename TConfig>
void SimulationManager<TConfig>::startSimThread()
{

  // TODO Switch Update function to the SimThread update!

  if (!isSimThreadRunning())
  {

    setThreadToBeStopped(false);

    //Start Dynamics Thread===========================================
      initBeforeThreads();
      m_pThread = new boost::thread( boost::bind(&SimulationManager<TConfig>::threadRunRecord, &*this) );
      m_eSimThreadRunning = SimulationManagerBase::RECORD;
      m_pSimulationLog->logMessage(" SimulationManager:: Start Thread: SimThread in RECORD mode started ...");

  }else{
    m_pSimulationLog->logMessage("SimulationManager:: A SimThread is already running!");
  }
}


template<typename TConfig>
void SimulationManager<TConfig>::waitForSimThread(){
    m_pThread->join();
    m_eSimThreadRunning = SimulationManagerBase::NONE;
}

template<typename TConfig>
void SimulationManager<TConfig>::stopSimThread()
{

  if (isSimThreadRunning())
  {
    setThreadToBeStopped(true);
    m_pThread->join();
    m_pSimulationLog->logMessage("SimulationManager:: Stop Thread: SimThread has been stopped!");

    m_eSimThreadRunning = SimulationManagerBase::NONE;
  }else{
    m_pSimulationLog->logMessage("SimulationManager:: Stop Thread: SimThread is not running!");
  }
}
